#include "AIPlayer.h"
AIPlayer::AIPlayer(GameEngine* game_eng_, TextItem* tooltip_, std::string path): Player(game_eng_, tooltip_),s_tensor(DT_FLOAT, TensorShape({21168})), rnnState(DT_FLOAT, TensorShape({2, 1, 512})) {
	Scope root = Scope::NewRootScope();
	std::cout << "Loading graph "<<path<<std::endl;
	Status load_graph_status = LoadGraph(path, &session);
	if (!load_graph_status.ok()) {
		LOG(ERROR) << load_graph_status;
	}
}

void AIPlayer::Play() {
	while(CanMove()) {
		Tensor prediction = PredictMove();
		int m = prediction.flat<tensorflow::int32>()(0);
		int max = 3; int min = 0;
		std::cout<< "OPTIMAL "<<prediction.flat<tensorflow::int32>()(0)<<" SUBOPTIMAL "<<prediction.flat<tensorflow::int32>()(1)<<std::endl;

		if (recents.size()>3 && m==recents.rbegin()[1] && recents.rbegin()[0]==recents.rbegin()[2] && recents.rbegin()[0] != recents.rbegin()[1]) {
			std::cout << "######## SUBOPTIMAL"<<std::endl;
			//m = rand()%(max-min + 1) + min;
			prediction.flat<tensorflow::int32>()(1);
		}
		std::cout << "M"<<m<<std::endl;
		recents.push_back(m);
		MoveInDirection(m);
		qApp->processEvents();
		std::this_thread::sleep_for(std::chrono::milliseconds(80));
	}
	
}
Status AIPlayer::LoadGraph(const string& graph_file_name, unique_ptr<tensorflow::Session>* session) {
	tensorflow::GraphDef graph_def;
	Status load_graph_status = ReadBinaryProto(tensorflow::Env::Default(), graph_file_name, &graph_def);
	if (!load_graph_status.ok()) {
		return tensorflow::errors::NotFound("Failed to load graph at '", graph_file_name, "'");
	}
	session->reset(tensorflow::NewSession(tensorflow::SessionOptions()));
	Status session_create_status = (*session)->Create(graph_def);
	if (!session_create_status.ok()) {
		return session_create_status;
	}
	return Status::OK();
}

Tensor AIPlayer::PredictMove() {
	using namespace cv;

	//cout << s_tensor.vec<float>()(0);
	
	int sizes[] = {game_eng->GetWidth()+2, game_eng->GetHeight()+2, 3};

	vector<Mat> data(sizes[2]);
	vector<Mat> res_data(sizes[2]);
	
	// Init 3D matrix
	for (int z = 0; z < sizes[2]; ++z) {
		data[z] = Mat(sizes[0], sizes[1], CV_32F);
		// Creating outer frame
		data[z] = 1;
		auto roi = Rect(1, 1, game_eng->GetWidth(),game_eng->GetHeight());
		data[z](roi) = 0;
	}
	
	// Populating 3D matrix with game items

	// Filling player [type = 2]
		/*cv::Range ranges[3];
		ranges[1] = cv::Range(pos.x, pos.x+1+1);
		ranges[0] = cv::Range(pos.y, pos.y+1+1);
		ranges[2] = cv::Range(Item::BOY, Item::BOY+1);*/

		Mat roi=data[2](Rect(pos.x+1, pos.y+1, 1, 1));
		roi = Scalar(1);
		
	ItemsContainer::Iterator iter(game_eng->items_container);
	while (iter.HasNext()){
		Item* item = iter.GetNext();
		auto p = item->pos;
		/*cv::Range ranges[3];
		ranges[1] = cv::Range(p.x, p.x+1+1);
		ranges[0] = cv::Range(p.y, p.y+1+1);
		ranges[2] = cv::Range(item->type, item->type+1);*/

		Mat roi=data[item->type](Rect(p.x+1, p.y+1, 1, 1));
		roi = Scalar(item->intensity);
	}
	

	/*cout << "Float matrix"<<endl;
	for (int u=0; u<11; u++){
		for (int v=0; v<11; v++){
			cout<<(float)(data[2].at<float>(u,v))<<"\t";
		} cout << endl<<endl;
	}cout << endl;*/
	
	// Resizing to 84x84 matrices
	for (int z = 0; z < sizes[2]; ++z) {
		res_data[z] = Mat(84, 84, CV_32F);
		resize(data[z], res_data[z], cv::Size(84,84), 0, 0, INTER_NEAREST);
	}
	//cout <<endl<<endl<<endl;
	/*for (int u=0; u<84; u++){
		for (int v=0; v<84; v++){
			cout<<(float)(res_data[0].at<float>(u,v))<<"";
		} cout << endl;
	}cout << endl;

	  ofstream myfile;
	myfile.open ("/home/netsurf/Documenti/pyscratch/py/proto_cc.txt");
	*/

	// Moving matrix from opencv to tensorflow
	for (int z=0; z<3; z++)
		for(int i=0; i<84; i++) {
			for(int j=0; j<84; j++) {
				//auto idx=z*(84*84) + j*84 + i;
				auto idx=i*84*3+j*3+z;
				s_tensor.vec<float>()(idx)=res_data[z].at<float>(i,j);

				//cout << "z,i,j="<<z<<","<<i<<","<<j<< "; Putting "<< 1.0*s_tensor.vec<float>()(idx)<< " at " <<idx<<endl;
			}
		}

	/*for (int h=0; h<21168; h++)
	myfile << s_tensor.vec<float>()(h)<<endl;

	myfile.close();*/

	//using namespace tensorflow;
	std::vector<std::pair<string,Tensor> > inputs;
	std::vector<Tensor> outputs;
	/*auto poin = rnnState.flat<float>();
	for(int u=0; u<10; u++) {
		cout<<poin(u);
	}
	for(int u=2000; u<2010; u++) {
		cout<<poin(u);
	}
	cout<<endl;*/
	Input::Initializer uno(1);
	inputs.push_back(std::make_pair ("main_scalarinput", s_tensor));
	inputs.push_back(std::make_pair ("main_train_length",uno.tensor));
	inputs.push_back(std::make_pair ("main_state_in",rnnState));
	inputs.push_back(std::make_pair ("main_batch_size",uno.tensor));

	Status run_status;
	run_status = session->Run(inputs, {"main_state_out","main_predict","main_qout"}, {}, &outputs);
	if (!run_status.ok()) {
		LOG(ERROR) << "Running model failed: " << run_status;
	}
	//rnnState = DeepCopy(outputs[0]);
	rnnState = outputs[0];
	/*auto flaz=outputs[1].flat<tensorflow::int64>();
	cout << "outprediction"<< " #"<< (int) flaz(0)<<endl;*/
	
	//return outputs[1].flat<tensorflow::int64>()(0);
	return outputs[2];
}
